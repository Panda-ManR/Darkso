
//addr : 0x6407E501a017eCF9Ea94232876cD08E7CFF5A0aE

//pragma solidity >=0.7.0 <0.9.0;
pragma solidity ^0.8.0;
// SPDX-License-Identifier: None

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol";
import "pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol";


contract DARKSO is ERC20, Ownable {
    using SafeMath for uint256;

    uint256 private _totalSupply;
    string private _name = "DARKSO";
    string private _symbol = "DKSO";

    uint256 public _totalPresale;
//    address private _operationsWallet;
//    address private _rewardsVault;
    uint256 private PresaleIssue;
    uint8 private _tokenDecimals = 6;

//    bool private _isSwapActive = false;
//    bool private _creationPhase = true;

    IPancakeRouter02 public PancakeRouter;
    IPancakePair public PancakePair;

//    bool private _liquiditySemaphore = false;
//    bool private isSwapping = false;
//    bool private feeActivated = true;
    bool private canPresale = true;

    uint256 private _rate;


    address private lockedWallet;

    //0xF8a29F60Fd8923d6dD04B22bDa3e7730Aac35C98
    address private OpenWallet = 0x709cF061fEdEa616Ed02d45eE01231673C8759B8;


    //0xdc2e61ae8A109C10691967c9B4850F000214F2Ea
    address private liquidityWallet = 0xdc2e61ae8A109C10691967c9B4850F000214F2Ea;

    uint256 private _swapThreshold = 10000e18;

    uint256 private TokenWithdrawTime;

    struct PresaleRecord{
        uint256 issue;
                
        uint256 icoTotal;
        
        uint256 startTime;
        
        uint256 duration;
        
        uint256 maxLimitPerUser;

        uint256 receivedTotal;
        
        mapping(address => uint256) TokenAmount;
    }

    mapping(uint256 => PresaleRecord) public ICODB;

    modifier liquiditySemaphore() {
        if (!_liquiditySemaphor){
            _liquiditySemaphore = true;
            _;
            _liquiditySemaphore = false;
        }
    }

    modifier presaleIsOpen() {
        require( _totalPresale < ICODB[PresaleIssue].icoTotal, "Not enough tokens left");
        require( block.timestamp >= ICODB[PresaleIssue].startTime &&
            block.timestamp < ICODB[PresaleIssue].startTime + ICODB[PresaleIssue].duration,
                 "Presale is not in progrsess.");
        _;
    }

    event PresaleCreate(uint256 PresaleIssue, uint256 maxLimitPerUser, uint256 PresaleAmount, uint256 startTime, uint256 blocktimenow ,uint256 duration);

    event BuyTokens(uint256 PresaleIssue, address indexed from, uint256 tokenAmount);

    event TokenWithdraw(address OpenWallet, address lockedWallet, uint256 tokenAmount);

    constructor() ERC20(_name,_symbol) {
        lockedWallet = _msgSender();

        _mint(lockedWallet,260e12);
        _mint(OpenWallet,35e12);
        _mint(liquidityWallet,5e12);

        _totalSupply = _totalSupply.add(40e12);
        PresaleIssue = 0;
        TokenWithdrawTime = block.timestamp;

//        emit Transfer(lockedWallet, OpenWallet, liquidityWallet, _totalSupply);
    }
//    receive() external payable {}

    //add-------
    // function setOwner(address newOwner) public onlyOwner {
    //     require(newOwner != address(0), "DARKSO: Cannot set Owner to zero address");
    //     _setOwner(newOwner);
    // }

    function setRate(uint256 newRate) external onlyOwner{
        _rate = newRate;
    }

    function startPresale(
        uint256 PresaleAmount,
        uint256 startTime,
        uint256 duration,
//        uint256 TokenPrice,
        uint256 maxLimitPerUser
    )external onlyOwner{

        require( canPresale, "Presale will be disable until new token withdraw");
        require( block.timestamp >
            ICODB[PresaleIssue].startTime.add( ICODB[PresaleIssue].duration),
            "presale is not over yet");
        PresaleIssue = PresaleIssue.add(1);
        PresaleRecord storage ico = ICODB[PresaleIssue];
        ico.issue = PresaleIssue;
        //ico.price = TokenPrice;
        ico.icoTotal = PresaleAmount;
        ico.startTime = startTime;
        ico.duration = duration;
        ico.maxLimitPerUser = maxLimitPerUser;

        canPresale = false;
        _totalPresale = 0;

        _transfer(OpenWallet, address(this), PresaleAmount);

        emit PresaleCreate(
            PresaleIssue,
            //TokenPrice,
            maxLimitPerUser,
            PresaleAmount,
            startTime,
            block.timestamp,
            duration
        );
    }


    function Buy_Tokens() external presaleIsOpen() payable{

        require(msg.sender != address(0), "address is 0");

        require(PresaleIssue > 0, "Presale that does not exist");

        require( block.timestamp >= ICODB[PresaleIssue].startTime &&
            block.timestamp < ICODB[PresaleIssue].startTime + ICODB[PresaleIssue].duration,
                 "Presale is not in progrsess.");

        require( _totalPresale < ICODB[PresaleIssue].icoTotal, "Not enough tokens left");


        PresaleRecord storage record = ICODB[PresaleIssue];

        uint256 tokenAmount = _getTokenAmount(msg.value);
        require( record.TokenAmount[msg.sender].add(tokenAmount) <= record.maxLimitPerUser,
                 "amount cannot bigger than maxLimitAmount");
        
        record.TokenAmount[msg.sender] += tokenAmount;
        _totalPresale += tokenAmount;
        _transfer(address(this), msg.sender, tokenAmount);

        emit BuyTokens(PresaleIssue, msg.sender, tokenAmount);
    } 

    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate).div(10**(18-_tokenDecimals));
    }

    function decimals() public view override returns (uint8) {
        return _tokenDecimals;
    }

    function withdrawToken() external onlyOwner{

        require(block.timestamp - TokenWithdrawTime >= 30 days, "Now is not time for withdraw token");
        
        _transfer(lockedWallet, OpenWallet, 26e12);

        _totalSupply = _totalSupply.add(26e12);
        TokenWithdrawTime = block.timestamp;
        canPresale = true;
        emit TokenWithdraw(lockedWallet, OpenWallet, 26e12);
    }

    function withdrawToken_test(uint256 blocktime) external onlyOwner{

        require(blocktime - TokenWithdrawTime >= 30 days, "Now is not time for withdraw token");
        //_balances[lockedWallet] = _balances[lockedWallet].sub(26e12);
        //_balances[OpenWallet] = _balances[lockedWallet].add(26e12);
        
        _transfer(lockedWallet, OpenWallet, 26e12);

        _totalSupply = _totalSupply.add(26e12);
        TokenWithdrawTime = block.timestamp;
        canPresale = true;

        emit TokenWithdraw(lockedWallet, OpenWallet, 26e12);
    }


    function withdrawBNB(address payable recipient) public onlyOwner {
        require(address(this).balance > 0, 'Contract has no money');
        recipient.transfer(address(this).balance);
    }

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }
    
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        require(_msgSender() != lockedWallet, "lockedWallet cannot transfer tokens to another");
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function get_devwallets()public view onlyOwner returns(address, address, address){
        return (OpenWallet, lockedWallet, liquidityWallet);
    }

    function getblocktime() external view onlyOwner returns(uint256){
        return block.timestamp;    
    }


    // function distributeFees(uint256 amount) internal returns (bool) {
    //     bool didSendToMarketing = payable(_operationsWallet).send(amount);
    //     return didSendToMarketing;
    // }

  //   function _transfer(
  //       address from,
  //       address to,
  //       uint256 amount
  //   ) internal {

  // //       if (from != address(PancakePair) && !isSwapping && feeActivated && !_claimTransfer(from)) {
  // //           isSwapping = true;
  // //          uint256 ignoreBalance = payable(this).balance;
  // //          bool didSwap = _swapTokensForNative();
  // //          uint256 swapBalance = payable(this).balance;
  // //          uint256 profit = swapBalance.sub(ignoreBalance);
  // //            if (didSwap) distributeFees(profit);
  // //          isSwapping = false;
  // //      }

  //       _balances[from] = _balances[from].sub(amount, "DARKSO: transfer amount exceeds balance");
  //       _balances[to] = _balances[to].add(amount);

  //       emit Transfer(from, to, amount);
    
  //   }

    

    // function setPairAddress(address pair) public onlyOwner {
    //     require(pair != address(0), "DARKSO: Cannot set Pair to zero address");
    //     PancakePair = IPancakePair(pair);
    // }


    // function setRouterAddress(address router) public onlyOwner {
    //     require(router != address(0), "DARKSO: Cannot set Router to zero address");
    //     PancakeRouter = IPancakeRouter02(router);
    //     _approve(address(this), address(PancakeRouter), ~uint256(0));
    // }

    // function setOperationsVaultAddress(address vault) external onlyOwner {
    //     require(vault != address(0), "DARKSO: Cannot set Vault to zero address");
    //     _operationsWallet = vault;
    // }

    // function setRewardsVaultAddress(address vault) external onlyOwner {
    //     require(vault != address(0), "DARKSO: Cannot set Vault to zero address");
    //     _rewardsVault = vault;
    // }


    // function setPrivateSaleAddress(address privateSale) external onlyOwner {
    //     require(privateSale != address(0), "DARKSO: Cannot set PreSale to zero address");
    //     PrivateSale = privateSale;
    // }

    // function activateFeesOnTransfer() external onlyOwner {
    //     feeActivated = true;
    // }

    // function deactivateFeesOnTransfer() external onlyOwner {
    //     feeActivated = false;
    // }

    // function setSwapThreshold(uint256 threshold) external onlyOwner {
    //     require(threshold > 0, "DARKSO: Cannot set threshold to zero");
    //     _swapThreshold = threshold;
    // }

    
    // function _swapTokensForNative() internal liquiditySemaphore returns (bool) {
    //     uint256 contractBalance = IERC20(address(this)).balanceOf(address(this));
    //     if (contractBalance > _swapThreshold) {
    //         address[] memory path = new address[](2);
    //         path[0] = address(this);
    //         path[1] = PancakeRouter.WETH();

    //         PancakeRouter.swapExactTokensForETH(_swapThreshold, 0, path, address(this), block.timestamp);
    //         return true;
    //     }
    //     return false;
    // }

}